\section{Active Console}
In the process of visualization research, many hurdles involved with implementation specifics were cleared. This, however, did not address the ultimate goal of creating an interactive workflow tool that could be executed from code running inside of an existing C or Python project. Existing tools for manipulating graphs have a certain duality to them. There exists a clear distinction between the graphical and code domains inherent in workflows. Because Tigres follows an API model, it differs from many other tools in that Tigres is executed inside of a workflow rather than the other way around. This paradigm implies a much deeper relationship between coding and graphing. Therefore, it is undesirable at this point to develop a monolithic Java tool for describing workflows graphically.
	
	The need for Tigres to maintain tight integration with code while adding a visual layer implies a tool that can be executed within a workflow using libraries that are native to the given programming language - in this case Python. Such a tool provides several distinct advantages for our purposes. First, while workflow composition in Tigres is relatively simple, specifying large workflows can become tedious. An interface that could generate large chunks of Python code with a minimal instruction set is, therefore, highly desirable. Second, in addition to code generation, this graph could assist in the prototyping of workflows by offering a 'dry-run' visualization. This is advantageous because current implementations of the monitoring module only operate during execution. This requires that methods, executables, inputs and types all be specified in advance. By interfacing directly with the active notepad, the use of Tigres types for graph generation is bypassed and no call to execution is necessary. Lastly, the major advantage of using such an interface would be its ability tie together the code generation and visual aspects of the tool. For example, a user could quickly specify a workflow using the active notepad application using the reduced command set. This would result in generation of the code necessary to implement this workflow in tigress along with a visualization of the workflow execution. Referring to the output of the real-time visualization, a user and his or her collaborators could quickly identify problems with the workflow or modify their algorithm by physically manipulating nodes in a drag and drop style. The result of such an implementation would be a tool that ties together the visual and coding domains seamlessly, with the choice of being executed as a simple Tkinter and or GTK application in python, or serve as the basis for a dedicated editor where a user could quickly move between domains. 
	
	The idea of a workflow tool that could emphasize the code/graphic relationship has been inspired by several code editors and program interfaces that give realtime feedback to users writing code. Mathematica allows users to write a brief snippet of code and execute it within the editor. The output of such an execution is displayed in-line with the code and can take the form of a graphical or textual output. In order to improve the feel and response of the application, cues were taken from the Google real-time search bar. With google's new search bar, users can see responses to their queries as they type. This is desirable for our purposes because it removes the need for specific execution commands, and results in an interface that feels less like a command line. 
	
	Several open source editors built entirely in Python currently exist which could be extended to include the desired functionality, along with modern features of a python editor like smart indenting, code highlighting and so on. For our purpose, the idea is to get a working prototype to test user response and it is therefore not necessary to offer such functionality just yet. Instead, this tool uses a built in python library, TkInter. TkInter offers a fairly extensive GUI construction toolset, and comes standard with every python installation. The functionality of this package is sufficiently broad to produce the desired interface with an active notepad, and code generation output area. Getting 'dot' output to display in a TkInter window is not a straightforward task, however. To accomplish this, a library called XDot is used which offers some functionality for interactivity by offering node and edge highlighting features. Implemented using GTK, another GUI library for Python, the 'dot' viewer window features a smart zoom for honing in on specific pieces of workflow execution. Although this library does not currently offer the ability to modify graph by dragging and dropping nodes, It holds considerable promise for future development of more interactive features. 
	
	With the three main UI components in place, constructing the desired 'active console' was a matter of implementation details. The first step was to build a TkInter window that could accept text in a notepad style. In order to embed the real-time  functionalities of the editor, some mechanism for parsing upon editor input was needed. By interfacing with the TkInter action listeners, it was possible to execute a parsing script on upon every key press. 
	
	In order to accept the minimized command set that the editor works with, it was necessary to build the framework to detect when a user had specified a template, and furthermore, to find out if they were ready to generate code output or quit the editor. The use of a fully feature parser was considered for this purpose, but with a minimal command set consisting of six commands - sequence, parallel, split, merge, generate and exit - It was found to be much more practical to employ regular expressions. For speed considerations, since a total of six regular expressions would need to be detected upon each key press, a multithreaded solution was implemented. Upon receiving a key press, all 6 regular expressions were assigned to a function, each being the target of its own thread. Because TkInter windows are generally considered to not be thread safe, a function that pipes input to the window was created to assuage these concerns. After a key press, and a call to all 6 regular expression processes is made, each of the functions puts all of its match items onto a queue, where the regular expression 'exit' and 'generate' get their own queue for special considerations. After a join stage, each of the tasks in the queue are placed into a list and sorted based upon their index tuple to accurately represent the execution order of the given workflow. This process occurs continually, unless a match in the exit/generate queue s found, in which case the program quits, or a call to the code generation module, dubbed 'console', is made. A secondary function of the keyPress action listener inherent to the TkInter window is the production of 'dot' graphs. With the appropriate algorithms in place from the visualization stage, this functionality was a matter of extending the functions which converted a workflow of Tigres types to a graph to also accept the minimal command set of the interface. In order to output this graph in it's own window, XDot is employed to call 'dot's graphing algorithms. 